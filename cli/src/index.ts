// This file is part of midnightntwrk/example-counter.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*
 * This file is the main driver for the Ataulfo example.
 * The entry point is the run function, at the end of the file.
 * We expect the startup files (testnet-remote.ts, standalone.ts, etc.) to
 * call run with some specific configuration that sets the network addresses
 * of the servers this file relies on.
 */

import * as crypto from 'crypto';
import { createInterface, type Interface } from 'node:readline/promises';
import { stdin as input, stdout as output } from 'node:process';
import { WebSocket } from 'ws';
// import { webcrypto } from 'crypto';
import {
  type AtaulfoProviders,
  AtaulfoAPI,
  type AtaulfoDerivedState,
  type DeployedAtaulfoContract,
  type PrivateStateId,
  ataulfoPrivateStateKey,
} from '../../api/src/index';
import { ledger, type Ledger, Offer } from '../../contract/src/managed/ataulfo/contract/index.cjs';
import {
  type BalancedTransaction,
  createBalancedTx,
  type MidnightProvider,
  type UnbalancedTransaction,
  type WalletProvider,
} from '@midnight-ntwrk/midnight-js-types';
import { type Wallet } from '@midnight-ntwrk/wallet-api';
import * as Rx from 'rxjs';
import { type CoinInfo, nativeToken, persistentHash, Transaction, type TransactionId } from '@midnight-ntwrk/ledger';
import { Transaction as ZswapTransaction } from '@midnight-ntwrk/zswap';
import { NodeZkConfigProvider } from '@midnight-ntwrk/midnight-js-node-zk-config-provider';
import { type Resource, WalletBuilder } from '@midnight-ntwrk/wallet';
import { indexerPublicDataProvider } from '@midnight-ntwrk/midnight-js-indexer-public-data-provider';
import { httpClientProofProvider } from '@midnight-ntwrk/midnight-js-http-client-proof-provider';
import { type Logger } from 'pino';
import { type Config, StandaloneConfig } from './config.js';
import type { StartedDockerComposeEnvironment, DockerComposeEnvironment } from 'testcontainers';
import { levelPrivateStateProvider } from '@midnight-ntwrk/midnight-js-level-private-state-provider';
import { type ContractAddress } from '@midnight-ntwrk/compact-runtime';
import { toHex, assertIsContractAddress } from '@midnight-ntwrk/midnight-js-utils';
import { getLedgerNetworkId, getZswapNetworkId } from '@midnight-ntwrk/midnight-js-network-id';

// @ts-expect-error: It's needed to enable WebSocket usage through apollo
globalThis.WebSocket = WebSocket;

/* **********************************************************************
 * getAtaulfoLedgerState: a helper that queries the current state of
 * the data on the ledger, for a specific Ataulfo contract.
 * Note that the Ledger type returned here is not some generic,
 * abstract ledger object, but specifically the type generated by
 * the Compact compiler to correspond to the ledger declaration
 * in the Ataulfo contract.
 */

export const getAtaulfoLedgerState = async (
  providers: AtaulfoProviders,
  contractAddress: ContractAddress,
): Promise<Ledger | null> => {
  assertIsContractAddress(contractAddress);
  const contractState = await providers.publicDataProvider.queryContractState(contractAddress);
  return contractState != null ? ledger(contractState.data) : null;
};
// providers.publicDataProvider
//   .queryContractState(contractAddress)
//   .then((contractState) => (contractState != null ? ledger(contractState.data) : null));

/* **********************************************************************
 * deployOrJoin: returns a contract, by prompting the user about
 * whether to deploy a new one or join an existing one and then
 * calling the appropriate helper.
 */

const DEPLOY_OR_JOIN_QUESTION = `
You can do one of the following:
  1. Deploy a new Ataulfo contract
  2. Join an existing Ataulfo contract
  3. Exit
Which would you like to do? `;

const deployOrJoin = async (providers: AtaulfoProviders, rli: Interface, localSecretKey: Uint8Array, logger: Logger): Promise<AtaulfoAPI | null> => {
  let api: AtaulfoAPI | null = null;

  while (true) {
    const choice = await rli.question(DEPLOY_OR_JOIN_QUESTION);
    switch (choice) {
      case '1':
        const nftName = await rli.question('What is the NFT name for the assets? ');
        const nftSymbol = await rli.question('What is the NFT symbol for the assets? ');
        const operationsFee = await rli.question('What is the operations fee to charge by the contract? ');
        api = await AtaulfoAPI.deploy(providers, nftName, nftSymbol, localSecretKey, BigInt(operationsFee.trim()), logger);
        logger.info(`Deployed contract at address: ${api.deployedContractAddress}`);
        return api;
      case '2':
        api = await AtaulfoAPI.join(providers, await rli.question('What is the contract address (in hex)? '), localSecretKey, logger);
        logger.info(`Joined contract at address: ${api.deployedContractAddress}`);
        return api;
      case '3':
        logger.info('Exiting...');
        return null;
      default:
        logger.error(`Invalid choice: ${choice}`);
    }
  }
};

/* **********************************************************************
 * displayLedgerState: shows the values of each of the fields declared
 * by the contract to be in the ledger state of the Ataulfo.
 */

const displayLedgerState = async (
  providers: AtaulfoProviders,
  deployedAtaulfoContract: DeployedAtaulfoContract,
  logger: Logger,
): Promise<void> => {
  const contractAddress = deployedAtaulfoContract.deployTxData.public.contractAddress;
  const ledgerState = await getAtaulfoLedgerState(providers, contractAddress);
  if (ledgerState === null) {
    logger.info(`There is no Ataulfo contract deployed at ${contractAddress}`);
  } else {
    if (ledgerState.offers.size() === 0n) {
      logger.info(`No offers`);
    } else {
      logger.info(`Current offers:`);
      for (const [id, offer] of ledgerState.offers) {
        let assetOwner;
        if (offer.assetOwner.is_left) {
          assetOwner = toHex(offer.assetOwner.left.bytes);
        } else {
          assetOwner = toHex(offer.assetOwner.right.bytes);
        }

        logger.info(`- Id: ${toHex(id)}, assetOwner: ${assetOwner}, asset: ${offer.assetId}, price: ${offer.price}`);
      }
    }

    if (ledgerState.accounts.size() === 0n) {
      logger.info(`No accounts`);
    } else {
      logger.info(`Current accounts:`);
      for (const [key, balance] of ledgerState.accounts) {
        logger.info(`- Key: ${toHex(key)}, balance: ${balance}`);
      }
    }

    logger.info(`Operations fee: ${ledgerState.opsFee}`);
    logger.info(`Treasury balance: ${ledgerState.treasury.value}`);
    logger.info(`Accounts total balance: ${ledgerState.accountsTotalBalance}`);
  }
};

/* **********************************************************************
 * displayPrivateState: shows the hex-formatted value of the secret key.
 */

const displayPrivateState = async (providers: AtaulfoProviders, logger: Logger): Promise<void> => {
  const privateState = await providers.privateStateProvider.get(ataulfoPrivateStateKey);
  if (privateState === null) {
    logger.info(`There is no existing Ataulfo private state`);
  } else {
    logger.info(`Current secret key is: ${toHex(privateState.secretKey)}`);
  }
};

/* **********************************************************************
 * displayDerivedState: shows the values of derived state which is made
 * by combining the ledger state with private state. In this example, the
 * derived state compares the owner's key with the private secret key to
 * determine if the current user is the owner of the current message.
 */

const displayDerivedState = (ledgerDerivedState: AtaulfoDerivedState | undefined, logger: Logger) => {
  if (ledgerDerivedState === undefined) {
    logger.info(`No Ataulfo state currently available`);
  } else {
    logger.info(`This contract was deployed by me? :${ledgerDerivedState.isContractOwner}`);

    logger.info(`My balance:${ledgerDerivedState.balance}`);
    logger.info(`Current offers:`);
    for (const [id, [offer, isMine]] of ledgerDerivedState.offers) {
      logger.info(`- My offer?: ${isMine}, Id: ${id}, asset: ${offer.assetId}, price: ${offer.price}`);
    }
    logger.info(`My offers published:${ledgerDerivedState.offersPublished}`);
  }
};

/* **********************************************************************
 * mainLoop: the main interactive menu of the Ataulfo CLI.
 * Before starting the loop, the user is prompted to deploy a new
 * contract or join an existing one.
 */

const MAIN_LOOP_QUESTION = `
You can do one of the following:
  1. Mint a new asset
  2. Post a new offer
  3. Take down your offer
  4. Deposit funds to your account
  5. Withdraw funds from your account
  6. Query my balance
  7. Fulfill offer
  8. Withdraw collected fees
  9. Display the current public state (known by everyone)
  10. Display the current private state (known only to this DApp instance)
  11. Display the current derived state (known only to this DApp instance)
  12. Exit
Which would you like to do? `;

const mainLoop = async (wallet: Wallet, providers: AtaulfoProviders, rli: Interface, localSecretKey: Uint8Array, logger: Logger): Promise<void> => {
  logger.info(`Local secret key to use: ${toHex(localSecretKey)}`);
  const ataulfoApi = await deployOrJoin(providers, rli, localSecretKey, logger);
  if (ataulfoApi === null) {
    return;
  }
  let currentState: AtaulfoDerivedState | undefined;
  const stateObserver = {
    next: (state: AtaulfoDerivedState) => (currentState = state),
  };
  const subscription = ataulfoApi.state$.subscribe(stateObserver);
  while (true) {
    try {
      const choice = await rli.question(MAIN_LOOP_QUESTION);
      switch (choice) {
        case '1': {
          const assetId = await rli.question(`What asset Id do you want to mint? `);
          await ataulfoApi.mint(BigInt(assetId.trim()));
          break;
        }
        case '2': {
          const assetId = await rli.question(`What asset Id do you want to offer? `);
          const price = await rli.question(`What price do you want to offer the asset at? `);
          const meta = await rli.question(`What image URL do you want to associate with the offer? `);
          const offerId = await ataulfoApi.createOffer(BigInt(assetId.trim()), BigInt(price.trim()), meta.trim());
          logger.info(`Offer created with Id: ${offerId}`);
          break;
        }
        case '3':
          const offerId = await rli.question(`What offer do you want to cancel? `);
          const offer = await ataulfoApi.cancelOffer(offerId);
          logger.info(`Offer cancelled, Id: ${offerId}, asset: ${offer.assetId}, price: ${offer.price}`);
          break;
        case '4':
          const amount = await rli.question(`What amount do you want to deposit? `);
          const [amountDeposited, newBalance] = await ataulfoApi.depositFunds(BigInt(amount.trim()));
          logger.info(`Net amount deposited after fee: ${amountDeposited}, new balance: ${newBalance}`);
          break;
        case '5':
          const withdrawAmount = await rli.question(`What amount do you want to withdraw? `);
          const updatedBalance = await ataulfoApi.withdrawFunds(BigInt(withdrawAmount.trim()));
          logger.info(`Funds withdrawn: ${withdrawAmount}, new balance: ${updatedBalance}`);
          break;
        case '6':
          const balance = await ataulfoApi.balance();
          logger.info(`Your current deposited balance: ${balance}`);
          break;
        case '7':
          const id = await rli.question(`Which offer do you want to fulfill? `);
          const fulfilledOffer = await ataulfoApi.fulfillOffer(id);
          logger.info(`Offer fulfilled: ${id}`);
          break;
        case '8':
          const collectedFees = await ataulfoApi.withdrawCollectedFees();
          logger.info(`Collected fees withdrawn: ${collectedFees}`);
          break;
        case '9':
          await displayLedgerState(providers, ataulfoApi.deployedContract, logger);
          break;
        case '10':
          await displayPrivateState(providers, logger);
          break;
        case '11':
          displayDerivedState(currentState, logger);
          break;
        case '12':
          logger.info('Exiting...');
          return;
        default:
          logger.error(`Invalid choice: ${choice}`);
      }
    } catch (e) {
      logger.error(`Error occurred: ${e}`);
    }
  }
  // While we allow errors to bubble up to the 'run' function, we will always need to dispose of the state
  // subscription when we exit.
  //    subscription.unsubscribe();
};

/* **********************************************************************
 * createWalletAndMidnightProvider: returns an object that
 * satifies both the WalletProvider and MidnightProvider
 * interfaces, both implemented in terms of the given wallet.
 */

const createWalletAndMidnightProvider = async (wallet: Wallet): Promise<WalletProvider & MidnightProvider> => {
  const state = await Rx.firstValueFrom(wallet.state());
  return {
    coinPublicKey: state.coinPublicKey,
    encryptionPublicKey: state.encryptionPublicKey,
    balanceTx(tx: UnbalancedTransaction, newCoins: CoinInfo[]): Promise<BalancedTransaction> {
      return wallet
        .balanceTransaction(
          ZswapTransaction.deserialize(tx.serialize(getLedgerNetworkId()), getZswapNetworkId()),
          newCoins,
        )
        .then((tx) => wallet.proveTransaction(tx))
        .then((zswapTx) => Transaction.deserialize(zswapTx.serialize(getZswapNetworkId()), getLedgerNetworkId()))
        .then(createBalancedTx);
    },
    submitTx(tx: BalancedTransaction): Promise<TransactionId> {
      return wallet.submitTransaction(tx);
    },
  };
};

/* **********************************************************************
 * waitForFunds: wait for tokens to appear in a wallet.
 *
 * This is an interesting example of watching the stream of states
 * coming from the pub-sub indexer.  It watches both
 *  1. how close the state is to present reality and
 *  2. the balance held by the wallet.
 */

const waitForFunds = (wallet: Wallet, logger: Logger) =>
  Rx.firstValueFrom(
    wallet.state().pipe(
      Rx.throttleTime(10_000),
      Rx.tap((state) => {
        const scanned = state.syncProgress?.synced ?? 0n;
        const behind = state.syncProgress?.lag.applyGap.toString() ?? 'unknown number';
        logger.info(`Wallet processed ${scanned} indices, remaining ${behind}`);
      }),
      Rx.filter((state) => {
        // Let's allow progress only if wallet is close enough
        const synced = typeof state.syncProgress?.synced === 'bigint' ? state.syncProgress.synced : 0n;
        const total = typeof state.syncProgress?.lag?.applyGap === 'bigint' ? state.syncProgress.lag.applyGap : 1_000n;
        return total - synced < 100n;
      }),
      Rx.map((s) => s.balances[nativeToken()] ?? 0n),
      Rx.filter((balance) => balance > 0n),
    ),
  );

/* **********************************************************************
 * buildWalletAndWaitForFunds: the main function that creates a wallet
 * and waits for tokens to appear in it.  The various "buildWallet"
 * functions all arrive here after collecting information for the
 * arguments.
 */

const buildWalletAndWaitForFunds = async (
  { indexer, indexerWS, node, proofServer }: Config,
  logger: Logger,
  seed: string,
): Promise<[Wallet & Resource, Uint8Array]> => {
  const wallet = await WalletBuilder.build(
    indexer,
    indexerWS,
    proofServer,
    node,
    seed,
    getZswapNetworkId(),
    'warn',
  );
  wallet.start();
  const state = await Rx.firstValueFrom(wallet.state());
  logger.info(`Your wallet seed is: ${seed}`);
  logger.info(`Your wallet address is: ${state.address}`);
  let balance = state.balances[nativeToken()];
  if (balance === undefined || balance === 0n) {
    logger.info(`Your wallet balance is: 0`);
    logger.info(`Waiting to receive tokens...`);
    balance = await waitForFunds(wallet, logger);
  }
  logger.info(`Your wallet balance is: ${balance}`);
  return [wallet, Uint8Array.from(seed)];
};

export const randomSeed = (): Uint8Array => {
  const bytes = new Uint8Array(32);
  crypto.getRandomValues(bytes);
  return bytes;
};

// Generate a random see and create the wallet with that.
const buildFreshWallet = async (config: Config, logger: Logger): Promise<[Wallet & Resource, Uint8Array]> =>
  await buildWalletAndWaitForFunds(config, logger, toHex(randomSeed()));

// Prompt for a seed and create the wallet with that.
const buildWalletFromSeed = async (config: Config, rli: Interface, logger: Logger): Promise<[Wallet & Resource, Uint8Array]> => {
  const seed = await rli.question('Enter your wallet seed: ');
  return await buildWalletAndWaitForFunds(config, logger, seed);
};

/* ***********************************************************************
 * This seed gives access to tokens minted in the genesis block of a local development node - only
 * used in standalone networks to build a wallet with initial funds.
 */
const GENESIS_MINT_WALLET_SEED = '0000000000000000000000000000000000000000000000000000000000000001';

/* **********************************************************************
 * buildWallet: unless running in a standalone (offline) mode,
 * prompt the user to tell us whether to create a new wallet
 * or recreate one from a prior seed.
 */

const WALLET_LOOP_QUESTION = `
You can do one of the following:
  1. Build a fresh wallet
  2. Build wallet from a seed
  3. Exit
Which would you like to do? `;

const buildWallet = async (config: Config, rli: Interface, logger: Logger): Promise<[(Wallet & Resource) | null, Uint8Array | null]> => {
  if (config instanceof StandaloneConfig) {
    return await buildWalletAndWaitForFunds(config, logger, GENESIS_MINT_WALLET_SEED);
  }
  while (true) {
    const choice = await rli.question(WALLET_LOOP_QUESTION);
    switch (choice) {
      case '1':
        return await buildFreshWallet(config, logger);
      case '2':
        return await buildWalletFromSeed(config, rli, logger);
      case '3':
        logger.info('Exiting...');
        return [null, null];
      default:
        logger.error(`Invalid choice: ${choice}`);
    }
  }
};

const mapContainerPort = (env: StartedDockerComposeEnvironment, url: string, containerName: string) => {
  const mappedUrl = new URL(url);
  const container = env.getContainer(containerName);

  mappedUrl.port = String(container.getFirstMappedPort());

  return mappedUrl.toString().replace(/\/+$/, '');
};

/* **********************************************************************
 * run: the main entry point that starts the whole Ataulfo CLI.
 *
 * If called with a Docker environment argument, the application
 * will wait for Docker to be ready before doing anything else.
 */

export const run = async (config: Config, logger: Logger, dockerEnv?: DockerComposeEnvironment): Promise<void> => {
  const rli = createInterface({ input, output, terminal: true });
  let env;
  if (dockerEnv !== undefined) {
    env = await dockerEnv.up();

    if (config instanceof StandaloneConfig) {
      config.indexer = mapContainerPort(env, config.indexer, 'ataulfo-indexer');
      config.indexerWS = mapContainerPort(env, config.indexerWS, 'ataulfo-indexer');
      config.node = mapContainerPort(env, config.node, 'ataulfo-node');
      config.proofServer = mapContainerPort(env, config.proofServer, 'ataulfo-proof-server');
    }
  }
  const [wallet, seed] = await buildWallet(config, rli, logger);
  try {
    if (wallet !== null && seed !== null) {
      const walletAndMidnightProvider = await createWalletAndMidnightProvider(wallet);
      const providers = {
        privateStateProvider: levelPrivateStateProvider<PrivateStateId>({
          privateStateStoreName: config.privateStateStoreName,
        }),
        publicDataProvider: indexerPublicDataProvider(config.indexer, config.indexerWS),
        zkConfigProvider: new NodeZkConfigProvider<'createOffer'>(config.zkConfigPath),
        proofProvider: httpClientProofProvider(config.proofServer),
        walletProvider: walletAndMidnightProvider,
        midnightProvider: walletAndMidnightProvider,
      };
      const secretKey = crypto.createHash('sha256').update(seed).digest();
      await mainLoop(wallet, providers, rli, secretKey, logger);
    }
  } catch (e) {
    logError(logger, e);
    logger.info('Exiting...');
  } finally {
    try {
      rli.close();
      rli.removeAllListeners();
    } catch (e) {
      logError(logger, e);
    } finally {
      try {
        if (wallet !== null) {
          await wallet.close();
        }
      } catch (e) {
        logError(logger, e);
      } finally {
        try {
          if (env !== undefined) {
            await env.down();
            logger.info('Goodbye');
            process.exit(0);
          }
        } catch (e) {
          logError(logger, e);
        }
      }
    }
  }
};

function logError(logger: Logger, e: unknown) {
  if (e instanceof Error) {
    logger.error(`Found error '${e.message}'`);
    logger.debug(`${e.stack}`);
  } else {
    logger.error(`Found error (unknown type)`);
  }
}
