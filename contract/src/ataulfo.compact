pragma language_version >= 0.16 && <= 0.17;

import CompactStandardLibrary;

import Assets prefix Assets_;

// Asset owners and their corresponding balances.
//export { Assets_assetsOwners };

// Contract's own treasury of native tokens.
export ledger treasury: QualifiedCoinInfo;

// Flag to keep track whether there are coins stored on the treasury.
// Is there a better way so this flag is not needed???
ledger treasuryWithCoins: Boolean;

// Fee charged for each deposit/withdrawal/fulfillment operation.
export sealed ledger opsFee: Uint<128>;

// Creator and owner of the contract who can mint assets and withdraw collected operation fees.
export sealed ledger contractOwner: Bytes<32>;

// Sell offer
export struct Offer {
  // Owner of the offered asset where payment will be sent.
  assetOwner: Either<ZswapCoinPublicKey, ContractAddress>;
  // Id of the asset offered.
  assetId: Uint<128>;
  // Ownership ID
  ownership: Bytes<32>;
  // Price in native tokens for each unit of the offered asset/s.
  price: Uint<128>;
  // Number of shares on sale in this offer.
  shares: Uint<128>;
  // Minimum amount of shares on sale in this offer.
  minShares: Uint<128>;
  // Optional metadata for the asset, format and content to be interpreted by the dApp.
  meta: Opaque<'string'>;
}

// Accounts (hidden owner) and their deposited native tokens balances.
export ledger accounts: Map<Bytes<32>, Uint<128>>;

// The total balance of all accounts.
export ledger accountsTotalBalance: Uint<128>;

// Map of all current sell offers
export ledger offers: Map<Bytes<32>, Offer>;

// Witness for the local secret key used to manage deposited funds.
witness localSecretKey(): Bytes<32>;

/**
  * @description Initializes the contract by setting the base URI for all assets.
  *
  * @param {Opaque<"string">} uri - The base URI for all assets URIs.
  * @param {Uint<128>} fee - The fee to charge for each operation requested by the users to be collected by the cowner.
  */
constructor(uri: Opaque<"string">, fee: Uint<128>) {
  opsFee = disclose(fee);
  contractOwner = disclose(genHiddenOwner(getTxSender()));
  treasuryWithCoins = false;
}

/**
  * @description Mint a new asset with given Id and owned by the caller.
  *
  * Requirements:
  *
  * - The contract is initialized.
  * - The caller is the contract owner.
  *
  * @param {Uint<128>} id - The unique identifier for the asset.
  * @param {Uint<128>} value - The quantity of assets of this same type that are minted.
  * @return {Bytes<32>} - Ownership ID.
  */
export circuit mint(assetId: Uint<128>, shares: Uint<128>): Bytes<32> {
  assert(contractOwner == genHiddenOwner(getTxSender()), "Only the contract owner can mint new assets");
  return Assets_mint(contractOwner, assetId, shares);
}

/**
 * @description Returns the balance (amount of shares) the caller owns for assets of type `assetId`.
 *
 * Requirements:
 *
 * - The contract is initialized.
 * - The asset exists.
 *
 * @param {Uint<128>} assetId - The target asset of the balance query.
 * @return {Uint<128>} balance - Amount of shares the caller owns.
 */
export circuit assetBalance(assetId: Uint<128>, ownership: Bytes<32>): Uint<128> {
  return Assets_balance(assetId, ownership);
}

export circuit myAssetBalance(assetId: Uint<128>): Uint<128> {
  const hiddenOwner = genHiddenOwner(getTxSender());
  const ownership = Assets_genOwnershipId(assetId, hiddenOwner);
  return Assets_balance(assetId, ownership);
}

/**
 * @description Approve a party to create offers with the `assetId`.
 *
 * Requirements:
 *
 * - The contract is initialized.
 *
 * @param {Uint<128>} assetId - The target asset to approve.
 * @param {Either<ZswapCoinPublicKey, ContractAddress>} target - Who is given transfer approval.
 * @return {[]} - Empty tuple.
 */
export circuit setApproval(
                 assetId: Uint<128>,
                 ownership: Bytes<32>,
                 target: Either<ZswapCoinPublicKey, ContractAddress>,
                 approved: Boolean
                 ): [] {
  Assets_setApproval(assetId, ownership, target, approved);
}

/**
 * @description Returns whether the caller is caller is approved on the `assetId`.
 *
 * Requirements:
 *
 * - The contract is initialized.
 *
 * @param {Uint<128>} assetId - The target asset to check approval.
 * @param {Either<ZswapCoinPublicKey, ContractAddress>} owner - Owner of the asset.
 * @return {Boolean} - Whether the caller is approved.
 */
export circuit isApproved(assetId: Uint<128>, ownership: Bytes<32>): Boolean {
  return Assets_isOwnerOrApproved(getTxSender(), assetId, ownership);
}

export circuit isApprovedOperator(
                 operator: Either<ZswapCoinPublicKey, ContractAddress>,
                 assetId: Uint<128>,
                 ownership: Bytes<32>
                 ): Boolean {
  return Assets_isOwnerOrApproved(operator, assetId, ownership);
}

/**
 * @description Approve or remove `operator` as an operator for the caller.
 * Operators can create offers for any token owned by the caller.
 *
 * Requirements:
 *
 * - The contract is initialized.
 * - The `operator` cannot be the address zero.
 *
 * @param {Either<ZswapCoinPublicKey, ContractAddress>} operator - An operator to manage the caller's tokens
 * @param {Boolean} approved - A boolean determining if `operator` may manage all tokens of the caller
 * @return {[]} - Empty tuple.
 */
export circuit setApprovalForAll(operator: ZswapCoinPublicKey, approved: Boolean): [] {
  //Assets_setApprovalForAll(operator, approved);
  return [];
}

/**
  * @description Withdraw collected fees.
  *
  * Requirements:
  *
  * - The contract is initialized.
  * - The caller is the contract owner.
  * - There are collected fees to withdraw while backing accounts deposits.
  *
  * @return {Uint<128>} - Balance withdrawn.
  */
export circuit withdrawCollectedFees(): Uint<128> {
  assert(contractOwner == genHiddenOwner(getTxSender()), "Only the contract owner can withdraw collected fees");

  // keep just enough funds to back accounts deposits
  const collectedFeesBalance = treasury.value - accountsTotalBalance;
  assert(collectedFeesBalance > 0, "No collected fees available for withdrawal");

  const sendResult = send(treasury, getTxSender(), disclose(collectedFeesBalance));
  assert(sendResult.sent.value == collectedFeesBalance, "Failed to send withdrawal of collected fees");
  if (sendResult.change.is_some) {
     const me = myAddr();
     treasury.writeCoin(sendResult.change.value, me);
  } else {
     treasuryWithCoins = false;
     treasury.resetToDefault();
  }

  return disclose(collectedFeesBalance);
}

/**
  * @description Publish a new offer for the specified `assetId` and given `price`.
  *
  * Requirements:
  *
  * - The contract is initialized.
  * - The price is greater than zero.
  * - The caller is the owner or operator of the asset to be published.
  * - The owner or operator owns at least the number of offered shares.
  * - The number of offered shares is greater or equal to the minimum set in the offer.
  * - The minimum of shares to fullfil the offer s greater than zero.
  *
  * @param {Uint<128>} assetId - Id of the asset the offer is for
  * @param {Uint<128>} shares - Number of shares on sale in this offer
  * @param {Uint<128>} min - Minimum amount of shares on sale in this offer,
  * @param {Uint<128>} price - Price of the asset in this offer
  * @param {Opaque<'string'>} meta - Metadata for the asset in this offer
  * @return {Bytes<32>} - The ID of the created offer.
  */
export circuit createOffer(
                 assetId: Uint<128>,
                 ownership: Bytes<32>,
                 shares: Uint<128>,
                 minShares: Uint<128>,
                 price: Uint<128>,
                 meta: Opaque<'string'>
                 ): Bytes<32> {
  assert(price > 0, "Price must be greater than zero");
  assert(minShares > 0, "Minimum of shares must be greater than zero");
  assert(shares >= minShares, "Number of shares must greater or equal to the minimum amount");

  const ownedBalance = assetBalance(assetId, ownership);
  assert(ownedBalance >= shares, "Not enough asset shares owned to create the offer");
  const publisher = getTxSender();
  assert(Assets_isOwnerOrApproved(publisher, assetId, ownership), "Offer publisher must be the owner or operator of the asset");

  // We just approve the contract for transfer
  const me = myAddr();
  Assets_setApproval(assetId, ownership, me, true);
  assert(Assets_isApproved(me, assetId, ownership), "Asset must be approved for the contract to be transfered");
  const offer = Offer { assetOwner: publisher,
                        assetId: assetId,
                        ownership: ownership,
                        price: price,
                        shares: shares,
                        minShares: minShares,
                        meta: meta };

  // insert offer in the offers map
  const offerId = disclose(genOfferId(ownership, price));
  offers.insert(offerId, disclose(offer));

  return offerId;
}

/**
  * @description Cancel the offer with the specified `offerId`.
  *
  * Requirements:
  *
  * - The contract is initialized.
  * - The offer exists.
  * - The caller is the publisher or the current owner of the asset.
  *
  * @param {Bytes<32>} offerId - Id of the offer to cancel
  * @return {Offer} - The offer just cancelled.
  */
export circuit cancelOffer(offerId: Bytes<32>): Offer {
  assert(offers.member(disclose(offerId)), "Offer does not exist");
  const offer = offers.lookup(disclose(offerId));
  const txSender = getTxSender();
  const isPublisher = (disclose(offerId) == genOfferId(offer.ownership, offer.price));
  assert(isPublisher || Assets_isOwnerOrApproved(txSender, offer.assetId, offer.ownership), "Offer can be cancelled by the publisher, asset owner, or approved party");

  const me = myAddr();
  setApproval(offer.assetId, offer.ownership, me, false);

  // remove the offer
  offers.remove(disclose(offerId));

  return offer;
}

/**
  * @description Deposit funds into the contract which can be used to make the payment when fulfilling an offer.
  *
  * Requirements:
  *
  * - The contract is initialized.
  * - The funds are in native token.
  * - The amount is greater than the contract defined operations fee.
  *
  * @param {CoinInfo} coinInfo - Information about the funds being deposited
  * @return {[Uint<128>, Uint<128>]} - Net amount deposited, i.e. after fees, and updated balance.
  */
export circuit depositFunds(coinInfo: CoinInfo): [Uint<128>, Uint<128>] {
  assert(coinInfo.color == nativeToken(), "Only native tokens can be deposited");
  assert(coinInfo.value > opsFee, "Deposit amount must be greater than the operations fee");

  receive(disclose(coinInfo));
  const me = myAddr();
  if (!treasuryWithCoins) {
     treasury.writeCoin(disclose(coinInfo), me);
     treasuryWithCoins = true;
  } else {
     const mergedCoin = mergeCoinImmediate(treasury, disclose(coinInfo));
     treasury.writeCoin(disclose(mergedCoin), me);
  }

  // we need to calculate the deposited value to account for contract fee
  const netAmount = (coinInfo.value - opsFee) as Uint<128>;
  accountsTotalBalance = (accountsTotalBalance + disclose(netAmount)) as Uint<128>;

  const balanceOwner = genHiddenOwner(getTxSender());
  if (accounts.member(disclose(balanceOwner))) {
     const balance = accounts.lookup(disclose(balanceOwner));
     const updatedBalance = (balance + netAmount) as Uint<128>;
     accounts.insert(disclose(balanceOwner), disclose(updatedBalance));
     return [netAmount, updatedBalance];
  } else {
     accounts.insert(disclose(balanceOwner), disclose(netAmount));
     return [netAmount, netAmount];
  }
}

/**
  * @description Withdraw deposited funds from the contract.
  *
  * Requirements:
  *
  * - The contract is initialized.
  * - The amount is greater than the contract defined operations fee.
  * - The caller has deposited balance and the amount is less than or equal to the deposited balance.
  *
  * @return {Uint<128>} - Amount to withdraw.
  * @return {Uint<128>} - Updated balance.
  */
export circuit withdrawFunds(amount: Uint<128>): Uint<128> {
  assert(amount > opsFee, "Withdraw amount must be greater than the operations fee");
  const balanceOwner = genHiddenOwner(getTxSender());
  assert(accounts.member(disclose(balanceOwner)), "No balance deposited to withdraw");
  const balance = accounts.lookup(disclose(balanceOwner));
  const grossAmount = (amount + opsFee) as Uint<128>;
  assert(balance >= grossAmount, "Insufficient balance to withdraw the requested amount and pay the operation fee");

  // send back the funds to the sender
  const sendResult = send(treasury, getTxSender(), disclose(amount));
  assert(sendResult.sent.value == amount, "Failed to send withdrawal payment");
  if (sendResult.change.is_some) {
     const me = myAddr();
     treasury.writeCoin(sendResult.change.value, me);
  } else {
     treasuryWithCoins = false;
     treasury.resetToDefault();
  }

  // remove or update account of the caller
  const updatedBalance = (balance - grossAmount) as Uint<128>;
  if (disclose(updatedBalance) > 0) {
     accounts.insert(disclose(balanceOwner), disclose(updatedBalance));
  } else {
     accounts.remove(disclose(balanceOwner));
  }
  accountsTotalBalance = (accountsTotalBalance - disclose(grossAmount)) as Uint<128>;

  return updatedBalance;
}

/**
  * @description Query balance from the contract.
  *
  * Requirements:
  *
  * - The contract is initialized.
  *
  * @return {Uint<128>} - Current balance.
  */
export circuit balance(): Uint<128> {
  const balanceOwner = genHiddenOwner(getTxSender());
  if (accounts.member(disclose(balanceOwner))) {
     return accounts.lookup(disclose(balanceOwner));
  } else {
     return 0;
  }
}

/**
  * @description Return the current treasury balance.
  *
  * Requirements:
  *
  * - The contract is initialized.
  *
  * @return {Uint<128>} - Current treasury balance.
  */
export circuit treasuryBalance(): Uint<128> {
  return treasury.value;
}

/**
  * @description Fulfill an offer by transferring the asset to the caller and automatically making the payment to the publisher.
  *
  * Requirements:
  *
  * - The contract is initialized.
  * - The offer exists.
  * - The caller is not the publisher.
  * - The caller has sufficient deposited balance to cover the price of the offer and operation fee.
  *
  * @param {Bytes<32>} offerId - Id of the offer to fulfill.
  * @param {Uint<128>} shares - Amount of asset shares to buy.
  * @return {Offer} - The offer just fulfilled.
  */
export circuit fulfillOffer(offerId: Bytes<32>, shares: Uint<128>): Offer {
  assert(offers.member(disclose(offerId)), "Offer does not exist");
  const offer = offers.lookup(disclose(offerId));
  assert(shares <= offer.shares, "Amonut of shares is greater than available in this offer");
  assert(shares >= offer.minShares, "Amonut of shares is less than minimum required by offer");
  const me = myAddr();

  // Check if the asset is still approved for transfer
  const isAssetStillApproved = Assets_isApproved(me, offer.assetId, offer.ownership);
  if (!isAssetStillApproved) {
    offers.remove(disclose(offerId));
    assert(isAssetStillApproved, "The offer has been revoked by the owner");
  }

  const isPublisher = (offerId == genOfferId(offer.ownership, offer.price));
  assert(!isPublisher, "Offer cannot be fulfilled by the publisher");
  const balanceOwner = genHiddenOwner(getTxSender());
  assert(accounts.member(disclose(balanceOwner)), "No balance deposited to fulfill the offer and operation fee");
  const buyerBalance = accounts.lookup(disclose(balanceOwner));
  const grossPrice = offer.price + opsFee;
  assert(buyerBalance >= grossPrice, "Insufficient balance to fulfill the offer and operation fee");

  // transfer the asset to the buyer
  const buyer = getTxSender();
  Assets__transferFrom(offer.ownership, buyer, offer.assetId, shares);

  // send the tDUST payment to the publisher
  const sendResult = send(treasury, offer.assetOwner, disclose(offer.price));
  assert(sendResult.sent.value == offer.price, "Failed to send payment");
  if (sendResult.change.is_some) {
     treasury.writeCoin(sendResult.change.value, me);
  } else {
     treasuryWithCoins = false;
     treasury.resetToDefault();
  }

  // reduce balance of the buyer
  const buyerUpdatedBalance = (buyerBalance - grossPrice) as Uint<128>;
  if (buyerUpdatedBalance > 0) {
     accounts.insert(disclose(balanceOwner), buyerUpdatedBalance);
  } else {
     accounts.remove(disclose(balanceOwner));
  }
  accountsTotalBalance = (accountsTotalBalance - disclose(grossPrice)) as Uint<128>;

  // remove the offer
  // TODO: remove only if all shares were sold or remaining are less 
  // than minimum required by the offer
  offers.remove(disclose(offerId));

  return offer;
}

// Helper to get the transaction sender address.
circuit getTxSender(): Either<ZswapCoinPublicKey, ContractAddress> {
  return left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
}

// Helper to get the contract's address.
circuit myAddr(): Either<ZswapCoinPublicKey, ContractAddress> {
  return right<ZswapCoinPublicKey, ContractAddress>(kernel.self());
}

// Generate a unique offer ID based on the publisher, asset ID, and price.
// We include the publisher in the ID to support different operators offering the same asset.
export circuit genOfferId(ownership: Bytes<32>, price: Uint<128>): Bytes<32> {
  const publisher = localSecretKey();
  return disclose(persistentHash<Vector<4, Bytes<32>>>(
                    [pad(32, "offer_id:"), publisher, ownership, price as Field as Bytes<32>]))
         as
         Bytes<32>;
}

// Generate an owner ID based on the owner's secret key.
export circuit genHiddenOwner(pk: Either<ZswapCoinPublicKey, ContractAddress>): Bytes<32> {
  return Assets_genHiddenOwner(pk);
}
