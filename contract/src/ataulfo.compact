pragma language_version >= 0.16 && <= 0.17;

import CompactStandardLibrary;

import Assets prefix Assets_;

// Asset holders and their corresponding balances.
export { Assets_assetHoldings, Assets_genHoldingId };

// Contract's own treasury of native tokens.
export ledger treasury: QualifiedCoinInfo;

// Flag to keep track whether there are coins stored on the treasury.
// Is there a better way so this flag is not needed???
ledger treasuryWithCoins: Boolean;

// Fee charged for each deposit/withdrawal/fulfillment operation.
export sealed ledger opsFee: Uint<128>;

// Creator and owner of the contract who can mint assets and withdraw collected operation fees.
export sealed ledger contractOwner: Bytes<32>;

// Sell offer
export struct Offer {
  // Owner of the offered asset where payment will be sent.
  assetOwner: Either<ZswapCoinPublicKey, ContractAddress>;
  // Id of the asset offered.
  assetId: Uint<128>;
  // Holding ID
  holdingId: Bytes<32>;
  // Price in native tokens for each unit/share of the offered asset.
  price: Uint<128>;
  // Number of shares on sale in this offer.
  shares: Uint<128>;
  // Minimum amount of shares on sale in this offer.
  minShares: Uint<128>;
  // Optional metadata for the asset, format and content to be interpreted by the dApp.
  meta: Opaque<'string'>;
}

// Accounts (hidden owner) and their deposited native tokens balances.
export ledger accounts: Map<Bytes<32>, Uint<128>>;

// The total balance of all accounts.
export ledger accountsTotalBalance: Uint<128>;

// Map of all current sell offers
export ledger offers: Map<Bytes<32>, Offer>;

// Witness for the local secret key used to manage deposited funds.
witness localSecretKey(): Bytes<32>;

/**
  * @description Initializes the contract by setting the operations fee and contract owner.
  * Note: The uri parameter is not used in the implementation.
  *
  * @param {Opaque<"string">} uri - Unused parameter (originally intended for asset base URI).
  * @param {Uint<128>} fee - The fee charged for deposit, withdrawal, and fulfillment operations.
  */
constructor(uri: Opaque<"string">, fee: Uint<128>) {
  opsFee = disclose(fee);
  contractOwner = disclose(genHiddenOwner(getTxSender()));
  treasuryWithCoins = false;
}

/**
  * @description Mint new shares of an asset owned by the contract owner.
  * Assets are always minted to the contract owner, not the caller.
  *
  * Requirements:
  *
  * - The caller must be the contract owner.
  *
  * @param {Uint<128>} assetId - The unique identifier for the asset.
  * @param {Uint<128>} shares - The quantity of asset shares to mint.
  * @return {Bytes<32>} - The holding ID for the minted shares.
  */
export circuit mint(assetId: Uint<128>, shares: Uint<128>): Bytes<32> {
  assert(contractOwner == genHiddenOwner(getTxSender()), "Only the contract owner can mint new assets");
  return Assets_mint(contractOwner, assetId, shares);
}

/**
 * @description Returns the balance (amount of shares) for a specific holding ID of an asset.
 * This is a generic query that can check any holding, not just the caller's.
 *
 * Requirements:
 *
 * - The asset must exist.
 *
 * @param {Uint<128>} assetId - The target asset of the balance query.
 * @param {Bytes<32>} holdingId - The holding ID to query.
 * @return {Uint<128>} balance - Amount of shares in the holding (0 if holding doesn't exist).
 */
export circuit assetBalance(assetId: Uint<128>, holdingId: Bytes<32>): Uint<128> {
  return Assets_balance(assetId, holdingId);
}

/**
 * @description Returns the balance (amount of shares) the caller owns for assets of type `assetId`.
 * Generates the caller's holding ID automatically from their transaction sender identity.
 *
 * @param {Uint<128>} assetId - The target asset of the balance query.
 * @return {Uint<128>} balance - Amount of shares the caller owns (0 if no holding exists).
 */
export circuit myAssetBalance(assetId: Uint<128>): Uint<128> {
  const hiddenOwner = genHiddenOwner(getTxSender());
  const holdingId = Assets_genHoldingId(assetId, hiddenOwner);
  return Assets_balance(assetId, holdingId);
}

/**
 * @description Approve or revoke a party's ability to manage a specific holding of an asset.
 * The approved party can transfer shares and create offers for the holding.
 *
 * Requirements:
 *
 * - The caller must be the owner or an already-approved operator of the holding.
 *
 * @param {Uint<128>} assetId - The target asset.
 * @param {Bytes<32>} holdingId - The holding ID to approve/revoke.
 * @param {Either<ZswapCoinPublicKey, ContractAddress>} target - The party to approve/revoke.
 * @param {Boolean} approved - True to approve, false to revoke.
 * @return {[]} - Empty tuple.
 */
export circuit setApproval(
                 assetId: Uint<128>,
                 holdingId: Bytes<32>,
                 target: Either<ZswapCoinPublicKey, ContractAddress>,
                 approved: Boolean
                 ): [] {
  Assets_setApproval(assetId, holdingId, target, approved);
}

/**
 * @description Returns whether the caller is the owner or an approved operator for the holding.
 *
 * Requirements:
 *
 * - The asset and holding must exist.
 *
 * @param {Uint<128>} assetId - The target asset to check.
 * @param {Bytes<32>} holdingId - The holding ID to check approval for.
 * @return {Boolean} - True if the caller is the owner or approved operator, false otherwise.
 */
export circuit isApproved(assetId: Uint<128>, holdingId: Bytes<32>): Boolean {
  return Assets_isOwnerOrApproved(getTxSender(), assetId, holdingId);
}

/**
 * @description Returns whether a specific operator is the owner or an approved operator for the holding.
 *
 * Requirements:
 *
 * - The asset and holding must exist.
 *
 * @param {Either<ZswapCoinPublicKey, ContractAddress>} operator - The operator to check.
 * @param {Uint<128>} assetId - The target asset to check.
 * @param {Bytes<32>} holdingId - The holding ID to check approval for.
 * @return {Boolean} - True if the operator is the owner or approved, false otherwise.
 */
export circuit isApprovedOperator(
                 operator: Either<ZswapCoinPublicKey, ContractAddress>,
                 assetId: Uint<128>,
                 holdingId: Bytes<32>
                 ): Boolean {
  return Assets_isOwnerOrApproved(operator, assetId, holdingId);
}

/**
 * @description Approve or remove `operator` as an operator for the caller.
 * Operators can create offers for any token owned by the caller.
 *
 * Requirements:
 *
 * - The contract is initialized.
 * - The `operator` cannot be the address zero.
 *
 * @param {Either<ZswapCoinPublicKey, ContractAddress>} operator - An operator to manage the caller's tokens
 * @param {Boolean} approved - A boolean determining if `operator` may manage all tokens of the caller
 * @return {[]} - Empty tuple.
 */
export circuit setApprovalForAll(operator: ZswapCoinPublicKey, approved: Boolean): [] {
  // TODO!!!!!
  //Assets_setApprovalForAll(operator, approved);
  return [];
}

/**
  * @description Withdraw collected operation fees to the contract owner.
  * Collected fees are calculated as the treasury balance minus the total of all user deposits.
  * Only withdraws the excess above what's needed to back user deposits.
  *
  * Requirements:
  *
  * - The caller must be the contract owner.
  * - Collected fees must be greater than zero (treasury > accountsTotalBalance).
  *
  * @return {Uint<128>} - Amount of collected fees withdrawn.
  */
export circuit withdrawCollectedFees(): Uint<128> {
  assert(contractOwner == genHiddenOwner(getTxSender()), "Only the contract owner can withdraw collected fees");

  // keep just enough funds to back accounts deposits
  const collectedFeesBalance = treasury.value - accountsTotalBalance;
  assert(collectedFeesBalance > 0, "No collected fees available for withdrawal");

  const sendResult = send(treasury, getTxSender(), disclose(collectedFeesBalance));
  assert(sendResult.sent.value == collectedFeesBalance, "Failed to send withdrawal of collected fees");
  if (sendResult.change.is_some) {
     const me = myAddr();
     treasury.writeCoin(sendResult.change.value, me);
  } else {
     treasuryWithCoins = false;
     treasury.resetToDefault();
  }

  return disclose(collectedFeesBalance);
}

/**
  * @description Create a sell offer for asset shares at a specified price.
  * Automatically approves the contract to transfer the asset when the offer is fulfilled.
  * The offer ID is deterministically generated from the local secret key, holding ID, and price.
  *
  * Requirements:
  *
  * - The price must be greater than zero.
  * - The minimum shares must be greater than zero.
  * - The offered shares must be greater than or equal to the minimum shares.
  * - The caller must own at least the number of offered shares.
  * - The caller must be the owner or an approved operator of the holding.
  *
  * @param {Uint<128>} assetId - The asset ID for the offer.
  * @param {Bytes<32>} holdingId - The holding ID containing the shares.
  * @param {Uint<128>} shares - Number of shares on sale in this offer.
  * @param {Uint<128>} minShares - Minimum amount of shares required to fulfill the offer.
  * @param {Uint<128>} price - Price in native tokens per share (total cost = price * shares).
  * @param {Opaque<'string'>} meta - Optional metadata for the offer.
  * @return {Bytes<32>} - The unique ID of the created offer.
  */
export circuit createOffer(
                 assetId: Uint<128>,
                 holdingId: Bytes<32>,
                 shares: Uint<128>,
                 minShares: Uint<128>,
                 price: Uint<128>,
                 meta: Opaque<'string'>
                 ): Bytes<32> {
  assert(price > 0, "Price must be greater than zero");
  assert(minShares > 0, "Minimum of shares must be greater than zero");
  assert(shares >= minShares, "Number of shares must greater or equal to the minimum amount");

  const ownedBalance = assetBalance(assetId, holdingId);
  assert(ownedBalance >= shares, "Not enough asset shares owned to create the offer");
  const publisher = getTxSender();
  assert(Assets_isOwnerOrApproved(publisher, assetId, holdingId), "Offer publisher must be the owner or operator of the asset");

  // We just approve the contract for transfer
  const me = myAddr();
  Assets_setApproval(assetId, holdingId, me, true);
  assert(Assets_isApproved(me, assetId, holdingId), "Asset must be approved for the contract to be transfered");
  const offer = Offer { assetOwner: publisher,
                        assetId: assetId,
                        holdingId: holdingId,
                        price: price,
                        shares: shares,
                        minShares: minShares,
                        meta: meta };

  // insert offer in the offers map
  const offerId = disclose(genOfferId(localSecretKey(), holdingId, price));
  offers.insert(offerId, disclose(offer));

  return offerId;
}

/**
  * @description Cancel an existing offer and revoke the contract's approval to transfer the asset.
  * Removes the offer from the offers ledger.
  *
  * Requirements:
  *
  * - The offer must exist.
  * - The caller must be either the original publisher (verified by matching the offer ID generation)
  *   or the current owner/approved operator of the asset holding.
  *
  * @param {Bytes<32>} offerId - The ID of the offer to cancel.
  * @return {Offer} - The cancelled offer data.
  */
export circuit cancelOffer(offerId: Bytes<32>): Offer {
  assert(offers.member(disclose(offerId)), "Offer does not exist");
  const offer = offers.lookup(disclose(offerId));
  const txSender = getTxSender();
  const isPublisher =
                (disclose(offerId) == genOfferId(localSecretKey(), offer.holdingId, offer.price));
  assert(isPublisher || Assets_isOwnerOrApproved(txSender, offer.assetId, offer.holdingId), "Offer can be cancelled by the publisher, asset owner, or approved party");

  const me = myAddr();
  setApproval(offer.assetId, offer.holdingId, me, false);

  // remove the offer
  offers.remove(disclose(offerId));

  return offer;
}

/**
  * @description Deposit native tokens into the contract for the caller's account.
  * Deducts the operation fee from the deposit and credits the net amount to the caller.
  * Funds can be used to fulfill offers or withdrawn later.
  *
  * Requirements:
  *
  * - The coins must be native tokens.
  * - The deposit amount must be greater than the operations fee.
  *
  * @param {CoinInfo} coinInfo - Information about the coins being deposited.
  * @return {[Uint<128>, Uint<128>]} - Net amount deposited (after fee) and the caller's updated total balance.
  */
export circuit depositFunds(coinInfo: CoinInfo): [Uint<128>, Uint<128>] {
  assert(coinInfo.color == nativeToken(), "Only native tokens can be deposited");
  assert(coinInfo.value > opsFee, "Deposit amount must be greater than the operations fee");

  receive(disclose(coinInfo));
  const me = myAddr();
  if (!treasuryWithCoins) {
     treasury.writeCoin(disclose(coinInfo), me);
     treasuryWithCoins = true;
  } else {
     const mergedCoin = mergeCoinImmediate(treasury, disclose(coinInfo));
     treasury.writeCoin(disclose(mergedCoin), me);
  }

  // we need to calculate the deposited value to account for contract fee
  const netAmount = (coinInfo.value - opsFee) as Uint<128>;
  accountsTotalBalance = (accountsTotalBalance + disclose(netAmount)) as Uint<128>;

  const balanceOwner = genHiddenOwner(getTxSender());
  if (accounts.member(disclose(balanceOwner))) {
     const balance = accounts.lookup(disclose(balanceOwner));
     const updatedBalance = (balance + netAmount) as Uint<128>;
     accounts.insert(disclose(balanceOwner), disclose(updatedBalance));
     return [netAmount, updatedBalance];
  } else {
     accounts.insert(disclose(balanceOwner), disclose(netAmount));
     return [netAmount, netAmount];
  }
}

/**
  * @description Withdraw deposited native tokens from the contract to the caller.
  * Charges the operation fee in addition to the withdrawal amount.
  * The total deducted is (amount + opsFee) from the caller's balance.
  *
  * Requirements:
  *
  * - The withdrawal amount must be greater than the operations fee.
  * - The caller must have a deposited balance.
  * - The caller's balance must be sufficient to cover both the amount and the fee (amount + opsFee).
  *
  * @param {Uint<128>} amount - The amount to withdraw (excluding the fee).
  * @return {Uint<128>} - The caller's remaining balance after withdrawal and fee.
  */
export circuit withdrawFunds(amount: Uint<128>): Uint<128> {
  assert(amount > opsFee, "Withdraw amount must be greater than the operations fee");
  const balanceOwner = genHiddenOwner(getTxSender());
  assert(accounts.member(disclose(balanceOwner)), "No balance deposited to withdraw");
  const balance = accounts.lookup(disclose(balanceOwner));
  const grossAmount = (amount + opsFee) as Uint<128>;
  assert(balance >= grossAmount, "Insufficient balance to withdraw the requested amount and pay the operation fee");

  // send back the funds to the sender
  const sendResult = send(treasury, getTxSender(), disclose(amount));
  assert(sendResult.sent.value == amount, "Failed to send withdrawal payment");
  if (sendResult.change.is_some) {
     const me = myAddr();
     treasury.writeCoin(sendResult.change.value, me);
  } else {
     treasuryWithCoins = false;
     treasury.resetToDefault();
  }

  // remove or update account of the caller
  const updatedBalance = (balance - grossAmount) as Uint<128>;
  if (disclose(updatedBalance) > 0) {
     accounts.insert(disclose(balanceOwner), disclose(updatedBalance));
  } else {
     accounts.remove(disclose(balanceOwner));
  }
  accountsTotalBalance = (accountsTotalBalance - disclose(grossAmount)) as Uint<128>;

  return updatedBalance;
}

/**
  * @description Query the caller's deposited balance in the contract.
  * Returns 0 if the caller has no deposited funds.
  *
  * @return {Uint<128>} - The caller's current deposited balance.
  */
export circuit balance(): Uint<128> {
  const balanceOwner = genHiddenOwner(getTxSender());
  if (accounts.member(disclose(balanceOwner))) {
     return accounts.lookup(disclose(balanceOwner));
  } else {
     return 0;
  }
}

/**
  * @description Returns the total native token balance held in the contract's treasury.
  * This includes both user deposits and collected operation fees.
  *
  * @return {Uint<128>} - Current treasury balance in native tokens.
  */
export circuit treasuryBalance(): Uint<128> {
  return treasury.value;
}

/**
  * @description Fulfill an offer by purchasing the specified amount of shares.
  * Transfers asset shares to the caller and sends payment to the asset owner.
  * Charges the operation fee in addition to the purchase price.
  * If remaining shares fall below minShares, the offer is removed; otherwise it's updated with remaining shares.
  *
  * Requirements:
  *
  * - The offer must exist.
  * - The asset must still be approved for the contract to transfer.
  * - The shares amount must not exceed available shares in the offer.
  * - The shares amount must meet or exceed the offer's minimum shares requirement.
  * - The caller cannot be the original publisher of the offer.
  * - The caller must have a deposited balance.
  * - The caller's balance must cover (price * shares) + opsFee.
  *
  * @param {Bytes<32>} offerId - The ID of the offer to fulfill.
  * @param {Uint<128>} shares - The amount of asset shares to purchase.
  * @return {Offer} - The original offer data before fulfillment.
  */
export circuit fulfillOffer(offerId: Bytes<32>, shares: Uint<128>): Offer {
  assert(offers.member(disclose(offerId)), "Offer does not exist");
  const offer = offers.lookup(disclose(offerId));
  assert(shares <= offer.shares, "Amonut of shares is greater than available in this offer");
  assert(shares >= offer.minShares, "Amonut of shares is less than minimum required by offer");
  const me = myAddr();

  // Check if the asset is still approved for transfer
  const isAssetStillApproved = Assets_isApproved(me, offer.assetId, offer.holdingId);
  if (!isAssetStillApproved) {
    offers.remove(disclose(offerId));
    assert(isAssetStillApproved, "The offer has been revoked by the owner");
  }

  const isPublisher = (offerId == genOfferId(localSecretKey(), offer.holdingId, offer.price));
  assert(!isPublisher, "Offer cannot be fulfilled by the publisher");
  const balanceOwner = genHiddenOwner(getTxSender());
  assert(accounts.member(disclose(balanceOwner)), "No balance deposited to fulfill the offer and operation fee");
  const buyerBalance = accounts.lookup(disclose(balanceOwner));

  // TODO: prevent from overflowing
  const grossPrice = ((offer.price as Field) * disclose(shares)) + opsFee;
  assert(buyerBalance >= grossPrice as Uint<128>, "Insufficient balance to fulfill the offer and operation fee");

  // transfer the asset to the buyer
  const buyer = getTxSender();
  Assets__transferFrom(offer.holdingId, buyer, offer.assetId, shares);

  // send the tDUST payment to the publisher
  const sendResult = send(treasury, offer.assetOwner, disclose(offer.price));
  assert(sendResult.sent.value == offer.price, "Failed to send payment");
  if (sendResult.change.is_some) {
     treasury.writeCoin(sendResult.change.value, me);
  } else {
     treasuryWithCoins = false;
     treasury.resetToDefault();
  }

  // reduce balance of the buyer
  const buyerUpdatedBalance = (buyerBalance - grossPrice) as Uint<128>;
  if (buyerUpdatedBalance > 0) {
     accounts.insert(disclose(balanceOwner), buyerUpdatedBalance);
  } else {
     accounts.remove(disclose(balanceOwner));
  }
  accountsTotalBalance = (accountsTotalBalance - disclose(grossPrice)) as Uint<128>;

  // remove offer only if remaining shares are less than minimum required 
  // by the offer, otherwise update the offer keeping remaining shares as offered
  const remainingShares = disclose(offer.shares - shares);
  if (remainingShares < offer.minShares) {
     offers.remove(disclose(offerId));
  }
  else {
     const updatedOffer =
                   Offer { assetOwner: offer.assetOwner,
                           assetId: offer.assetId,
                           holdingId: offer.holdingId,
                           price: offer.price,
                           shares: remainingShares,
                           minShares: offer.minShares,
                           meta: offer.meta };

     offers.insert(disclose(offerId), updatedOffer);
  }

  return offer;
}

// Helper to get the transaction sender address.
circuit getTxSender(): Either<ZswapCoinPublicKey, ContractAddress> {
  return left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
}

// Helper to get the contract's address.
circuit myAddr(): Either<ZswapCoinPublicKey, ContractAddress> {
  return right<ZswapCoinPublicKey, ContractAddress>(kernel.self());
}

// Generate a unique offer ID based on the publisher (local secret key), holding ID, and price.
// Uses persistent hashing with the prefix "offer_id:".
// The publisher parameter is typically the local secret key, making offer IDs deterministic
// but private to the offer creator, preventing unauthorized cancellations.
export circuit genOfferId(publisher: Bytes<32>, holdingId: Bytes<32>, price: Uint<128>): Bytes<32> {
  return disclose(persistentHash<Vector<4, Bytes<32>>>(
                    [pad(32, "offer_id:"), publisher, holdingId, price as Field as Bytes<32>]))
         as
         Bytes<32>;
}

// Generate a hidden owner ID from a public key or contract address.
// Delegates to Assets_genHiddenOwner which uses persistent hashing with "hidden_owner:" prefix.
// This creates a privacy-preserving identifier for ownership tracking.
export circuit genHiddenOwner(pk: Either<ZswapCoinPublicKey, ContractAddress>): Bytes<32> {
  return Assets_genHiddenOwner(pk);
}
